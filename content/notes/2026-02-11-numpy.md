---
title: NumPy 的广播机制
date: 2026-02-11
excerpt: “强者向下兼容，弱者原地分身。”
---

## 什么是广播？
在 NumPy 里，两个数组要做加减乘除，按理说形状必须一模一样。 

但 NumPy 很聪明（也很懒），如果两个数组形状不一样，它会尝试**自动拉伸** 那个小的数组，让它变得和大的数组一样大，然后再运算。

这个“拉伸”的过程，就叫广播（Broadcasting）。


## 拉伸的门槛
NumPy 不是乱拉伸的，它有两个硬性门槛：

- 从后往前看：比较两个数组的维度，从最右边的维度（也就是最后一格）开始比。

- 要么相等，要么有一个是 1：如果这一维的数字一样，OK；如果其中一个是 1，它就能靠“分身术”变大；如果两个都不相等且都不是 1，直接报错（报 ValueError）。


### 例子

| **数组 A 形状** | **数组 B 形状** | **能广播吗？** | **理由** |
| --- | --- | --- | --- |
| (4, 3) | (3, ) | **YES** | 结尾都是 3，B 前面补个 1 就能分身。 |
| (4, 3) | (4, ) | **NO!** | 结尾一个是 3 一个是 4，死棋。 |
| (100, 1) | (1, 50) | **YES** | A 往左右分身，B 往上下分身，最后变 (100, 50)。 |


## 常见用法

---

### 1. 最常见的场景：数组 + 单个数字

这是最基础的“分身术”。

```python
import numpy as np

# 创建一个 2x3 的矩阵
a = np.array([[1, 2, 3], 
              [4, 5, 6]])

# 让整个矩阵都加 10
result = a + 10

print(result)
# 输出：
# [[11, 12, 13]
#  [14, 15, 16]]

```

**大脑补位：** 这里的 `10` 被 NumPy 瞬间克隆成了 `[[10, 10, 10], [10, 10, 10]]`。

---

### 2. 进阶场景：矩阵 + 行向量

想象一个 (3, 3) 的大方阵加一个 (1, 3) 的长条。

```python
a = np.array([[1, 1, 1],
              [2, 2, 2],
              [3, 3, 3]])

b = np.array([10, 20, 30])  # 形状是 (3,)

print(a + b)
# 输出：
# [[11, 21, 31]
#  [12, 22, 32]
#  [13, 23, 33]]

```

**发生了什么？** `b` 觉得自己只有一行，太矮了，于是它把自己复制了 3 份，叠成了 3 行，变得跟 `a` 一样高。

---

### 3. 终极奥义：横纵双向拉伸

这是最骚的操作。一个竖条加一个横条，它们会**互相配合分身**。

```python
x = np.array([[10], [20], [30]]) # 形状 (3, 1) - 竖条
y = np.array([1, 2])             # 形状 (2,)    - 横条

print(x + y)
# 结果会是一个 (3, 2) 的矩阵！
# [[11, 12]
#  [21, 22]
#  [31, 32]]

```

**分身过程：**

1. `x` 发现自己只有 1 列，于是向右分身，变出 2 列。
2. `y` 发现自己只有 1 行，于是向下分身，变出 3 行。
3. 两人在 (3, 2) 的空间里“顶峰相见”。
